import CouchDBStorage from './utils/CouchDBStorage'
import DataStorage from './utils/DataStorage'
import fetch from 'node-fetch'
import {
    isFn,
    generateHash,
    isArr
} from './utils/utils'
import PromisE from './utils/PromisE'

const countries = new CouchDBStorage(null, 'countries')
const URL_COUNTRIES_LIST = process.env.URL_COUNTRIES_LIST || 'https://restcountries.com/v3.1/all'
let countriesHash

// Get list of all countries
//
// Params:
// @hash        string: hash generated by the Map of existing countries to compare with the ones stored on the server
// @callback    function
export const handleCountries = async (hash, callback) => {
    if (!isFn(callback)) return
    if (countriesHash === hash) return callback()

    callback(null, await countries.getAll(null, true, 999))
}

export const isCountryCode = async (code) => !!(await countries.get(code))

// populate countries list from external source
export const setup = async () => {
    const existing = await countries.getAll(null, true, 999)
    if (existing.size > 0) {
        countriesHash = generateHash(Array.from(existing))
        return
    }

    console.log('Fetching list of countries...')
    // const getCountries = async () => await (await fetch(URL_COUNTRIES_LIST)).json()
    const countriesArr = await PromisE.fetch(url)
        .then(arr => {
            // save the entire result as JSON file as a backup
            new DataStorage('countries.json')
                .setAll(
                    new Map(
                        arr.map(c => [c.cca2, c])
                    )
                )
            return arr
        })
        .catch(err => {
            // failed to retrieve list of countries.
            // check if a JSON file is available
            const arr = new DataStorage('countries.json')
                .map(([_, c]) => c)
            return isArr(arr) && arr.length > 0
                ? arr // resolve with array
                : new Error(`Failed to retrieve countries. ${err}`) // reject with error
        })
    if (countriesArr.length === 0) return

    // convert array into Map and strip all unnecessary data
    const countriesMap = countriesArr.reduce((map, c) => {
        const { root, suffixes = [] } = c.idd || {}
        const suffix = suffixes.length > 1
            ? '' // ignore suffix if more than one available
            : suffixes[0]
        const { common, official } = c.name || {}
        let name = common || official
        const altSpellings = [...c.altSpellings]
        // use common name as primary name if available, otherwise use official name
        if (common !== official) {
            // add official name to alt spellings list
            !altSpellings.includes(official) && altSpellings.push(official)
        }
        return map.set(
            c.cca2, // use 2 letter code as key
            {
                altSpellings,
                name,
                code: c.cca2,     // 2 letter code
                code3: c.cca3,    // 3 letter code
                phoneCode: !root
                    ? undefined
                    : root + suffix,
                regexPostCode: (c.postalCode || {}).regex, // only some of the entries contains postalCode regex
            },
        )
    },
        new Map(),
    )

    countriesHash = generateHash(
        Array.from(countriesMap),
        'blake2',
        256,
    )
    await countries.setAll(countriesMap)
}


export default {

}